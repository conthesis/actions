import msgpack
import secrets
from enum import Enum
from typing import Any, Dict, List, Optional, Union

import orjson
from pydantic import BaseModel, Field

class PropertyKind(Enum):
    ENTITY = "ENTITY"
    CAS_POINTER = "CAS_POINTER"
    META_FIELD = "META_FIELD"
    META_ENTITY = "META_ENTITY"
    LITERAL = "LITERAL"
    PATH = "PATH"


class ActionSource(Enum):
    ENTITY = "ENTITY"
    LITERAL = "LITERAL"


class DataFormat(Enum):
    JSON = "JSON"


def encode_enum(x):
    if isinstance(x, (PropertyKind, ActionSource, DataFormat)):
        return x.value
    elif isinstance(x, BaseModel):
        return x.dict()
    else:
        return x


class ActionProperty(BaseModel):
    name: str
    kind: PropertyKind
    data_format: DataFormat = DataFormat.JSON
    value: Union[str, Dict, List, None, bytes]

    def copy_with(self, kind=None, value=None) -> "ActionProperty":
        return ActionProperty(
            name=self.name,
            data_format=self.data_format,
            value=value if value is not None else self.value,
            kind=kind if kind is not None else self.kind,
        )

    @staticmethod
    def many_to_bytes(items):
        return msgpack.packb(items, default=encode_enum)


    def simplify(self, meta) -> Optional["ActionProperty"]:
        if self.kind == PropertyKind.LITERAL:
            return self
        elif self.kind == PropertyKind.PATH:
            return self
        elif self.kind == PropertyKind.META_FIELD:
            return self.copy_with(PropertyKind.LITERAL, meta.get(self.value))
        elif self.kind == PropertyKind.META_ENTITY:
            if (res := meta.get(self.value)) is None:
                return self.copy_with(PropertyKind.LITERAL, None)
            else:
                return self.copy_with(PropertyKind.PATH, f"/entity/{res}")
        elif self.kind == PropertyKind.ENTITY:
            return self.copy_with(PropertyKind.PATH, f"/entity/{self.value}")
        else:
            return None



class Action(BaseModel):
    kind: str
    properties: List[ActionProperty]
    wildcard_triggers: Optional[List[str]] = []

    @classmethod
    def from_bytes(cls, data: bytes) -> "Action":
        try:
            return cls(**msgpack.unpackb(data))
        except:
            return cls(**orjson.loads(data))

    def to_bytes(self) -> bytes:
        return msgpack.packb(self.dict(), default=encode_enum)


def autogenerated_jid():
    return secrets.token_hex(16)


class ActionTrigger(BaseModel):
    meta: Dict[str, Any] = {}
    action_source: ActionSource
    action: Union[str, Action]
    jid: str = Field(default_factory=autogenerated_jid)

    @classmethod
    def from_bytes(cls, data: bytes) -> "Action":
        try:
            return cls(**msgpack.unpackb(data))
        except:
            return cls(**orjson.loads(data))

    def to_bytes(self) -> bytes:
        return msgpack.packb(self.dict(), default=encode_enum)


class ActionResult(BaseModel):
    success: bool

    def to_bytes(self) -> bytes:
        return msgpack.packb(self.dict(), default=encode_enum)
